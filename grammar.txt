getName := NAME
getString := STRING
getNumber := NUMBER
getBool := BOOL
getLabel := LABEL getTuple? getObject?
getList := LARRAY (getClause (COMMA getClause)* COMMA?)? RARRAY
getArray1D := LARRAY getClause (WHITESPACE getClause)* RARRAY
getArray2D := getArray1D (NEWLINE getArray1D)*
getTuple := LPAREN getClause (COMMA getClause)* RPAREN
getTupleName := BLANK | getName
getDefLHS := (LPAREN (getTupleName (COMMA getTupleName)*)? RPAREN) | getName
getNameDef := getDefLHS ASSIGN getClause
getFuncDef := getName LPAREN getName (COMMA getName)* RPAREN ASSIGN getClause
getDef := getFuncDef | getNameDef
getObject := LBRACKET getDef ((NEWLINE | SEMICOLON) getDef)* RBRACKET
getPair := getClause COLON getClause
getDict := LBRACKET (getPair (COMMA getPair)* COMMA?)? RBRACKET
getSet := LBRACKET getClause (COMMA getClause)* COMMA? RBRACKET
getArrayLiteral := getArray2d
getParenLiteral := LPAREN getClause RPAREN | getTuple
getBracketLiteral := LBRACKET RBRACKET | getObject | getDict | getSet
getUnitBase := getNumber
	      | getString
	      | getName
	      | getLabel
	      | getBool
	      | getArrayLiteral
	      | getParenLiteral
	      | getBracketLiteral
getIndex := LARRAY getClause RARRAY
getFieldRef := FIELD
getCall := LPAREN getClause (COMMA getClause)* RPAREN
getUnit := getUnitBase (getIndex | getFieldRef | getCall)*
getPrefixOp := (NEG | NOT)? getPrefixOp | getUnit
binPipe := binConcat (PIPE binConcat)*
binContact := binOr (CONCAT binConcat)*
binOr := binAnd (OR binAnd)*
binAnd := binEq ((EQUALS | NOTEQ) binEq)*
binIn := BinComp (IN BinComp)*
binComp := binTerm ((LESSTHAN | GREATERTHAN | LESSEQ | GREATEQ) binTerm)*
binTerm := binFactor ((ADD | SUB) binFactor)*
binFactor := binPower ((MUL | DIV | MOD) binPower)*
binPow := getPrefixOP (POW binPow)*
getOperation := binPipe
getConditional := IF getExpression THEN getClause ELSE getExpression
getCases := (CASE getExpression getClause)+ (ELSE getClause)?
getCond := COND LBRACKET getCases RBRACKET
getFor := FOR getDefLHS IN getExpression getListComp
getWhen := WHEN getExpression getListComp
getYield := YIELD getExpression
getListComp := getFor | getWhen | getYield
getLambda := ((LPAREN getName (COMMA getName)* RPAREN) | getName) LAMBDA getClause
getTry := TRY getClause CATCH getExpression getExpression
getThrow := THROW getExpression
getExpression := getConditional
		| getThrow
		| getTry
		| getCond
		| getCond
		| getFor
		| getListComp
		| getLambda
		| getOperation
getWhere := WHERE (getObject | getDef)
getDefineable := getIndex | getFieldRef
getWithDef := DOLLAR getDefineable ASSIGN getClause
getWith := LBRACKET (getWithDef  ((NEWLINE | SEMICOLON) getWithDef)*)? RBRACKET
getRequires := REQUIRES getOperation
getClause := getWhere | getRequires | getWith
getExport := EXPORT LBRACKET (getName (COMMA getName)*)? RBRACKET
getImport := IMPORT getString AS getName
getProgram := getExport? (getImport)* (getDef (NEWLINE | SEMICOLON))* EOF

# Notation Explanation
# Every full caps word is a token and every other sort of word is a reference to another definition
# Everything else is as you'd expect it to be from a somewhat formal grammar
# And btw, by "#" I just mean that the following line has nothing to do with the grammar

# When not explicitly used, NEWLINE, WHITESPACE, and COMMENT are skipped by default
